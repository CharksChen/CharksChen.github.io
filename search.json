[{"title":"快速幂的代码","url":"/2025/10/26/My-New-Post/","content":"对一个数的极大幂求余数的优化时间复杂度后的解法\n#include&lt;stdio.h&gt;int power(int a,int b,int p)&#123;   int r=1;   while(b)   &#123;      if(b&amp;1) r=(r*a%p);      a=a*a%p;      b&gt;&gt;=1;   &#125;   return r;&#125;int main()&#123;   int a,b,s,p;   scanf(&quot;%d %d %d&quot;,&amp;a,&amp;b,&amp;p);   s=power(a,b,p);   printf(&quot;%d^%d mod %d=%d&quot;,a,b,p,s);   return 0;&#125;","categories":["计算机"],"tags":["二分算法"]},{"title":"C语言中qsort函数","url":"/2025/10/26/The-second/","content":"#include&lt;stdlib.h&gt;\nqsort ( 数组第一个元素的地址，数数组中的元素个数，每个元素的大小，比较函数 )\n1、地址的话，像数组 a[10] ,直接写a就行。2、元素个数也是直接写。3、元素大小一般用 sizeof ( int ) 或者其他类型。4、比较函数，int compare ( const void * a ,const void * b){  return ( * ( int *) a -* (int *) b ) ;    }\n  return的东西可以改变   a - b 时是升序，b - a 时是降序 \n具体一点的用法如下：\n七种qsort排序方法 \n&lt;排序都是采用的从小到大排序&gt; \n一、对int类型数组排序 \nint num[100]; int cmp ( const void *a , const void *b ) &#123;      return *(int *)a - *(int *)b; &#125; qsort(num,100,sizeof(num[0]),cmp);\n\n二、对char类型数组排序（同int类型） \nchar word[50]; int cmp( const void *a , const void *b ) &#123;     return *(char *)a - *(int *)b; &#125; qsort(word,100,sizeof(word[0]),cmp);\n\n三、对double类型数组排序 \ndouble in[100]; int cmp( const void *a , const void *b ) &#123;      return *(double *)a &gt; *(double *)b ? 1 : -1; &#125; qsort(in,100,sizeof(in[0]),cmp)； \n\n四、对结构体一级排序 \nstruct In &#123;   double data;   int other; &#125;s[100] //按照data的值从小到大将结构体排序,关于结构体内的排序关键数据data的类型可以很多种，参考上面的例子写 int cmp( const void *a ,const void *b) &#123;    return (*(In *)a).data &gt; (*(In *)b).data ? 1 : -1; &#125; qsort(s,100,sizeof(s[0]),cmp); \n\n五、对结构体二级排序 \nstruct In &#123;   int x;   int y; &#125;s[100]; //按照x从小到大排序，当x相等时按照y从大到小排序 int cmp( const void *a , const void *b ) &#123;   struct In *c = (In *)a;   struct In *d = (In *)b;   if(c-&gt;x != d-&gt;x) return c-&gt;x - d-&gt;x;   else return d-&gt;y - c-&gt;y; &#125; qsort(s,100,sizeof(s[0]),cmp); \n\n六、对结构体三级排序（都是从小到大）\n#include&lt;stdlib.h&gt;typedef struct  item&#123;    int num,length,width;&#125;;int comp(const void *p1,const void *p2)&#123;    struct item *c=(item*)p1;    struct item *d=(item*)p2;    if(c-&gt;num!=d-&gt;num)    &#123;        return d-&gt;num&lt;c-&gt;num?1:-1;    &#125;    else if(c-&gt;length!=d-&gt;length&amp;&amp;c-&gt;num==d-&gt;num)    return d-&gt;length&lt;c-&gt;length?1:-1;    else return d-&gt;width&lt;c-&gt;width?1:-1;&#125;item ss[1200];qsort(ss,n,sizeof(ss[0]),comp);\n\n七、对字符串进行排序 \nstruct In &#123; int data; char str[100]; &#125;s[100]; //按照结构体中字符串str的字典顺序排序 int cmp ( const void *a , const void *b ) &#123; return strcmp( (*(In *)a)-&gt;str , (*(In *)b)-&gt;str ); &#125; qsort(s,100,sizeof(s[0]),cmp); \n\n八、计算几何中求凸包的cmp \nint cmp(const void *a,const void *b) //重点cmp函数，把除了1点外的所有点，旋转角度排序 &#123; struct point *c=(point *)a; struct point *d=(point *)b; if( calc(*c,*d,p[1]) &lt; 0) return 1; else if( !calc(*c,*d,p[1]) &amp;&amp; dis(c-&gt;x,c-&gt;y,p[1].x,p[1].y) &lt; dis(d-&gt;x,d-&gt;y,p[1].x,p[1].y)) //如果在一条直线上，则把远的放在前面 return 1; else return -1; &#125; \n","categories":["计算机"],"tags":["快速排序","结构体排序"]},{"title":"Memset初始化的运用","url":"/2025/10/27/The-third-blog/","content":"#include&lt;string.h&gt;\nmemset( void*s, char ch, unsigned n);\nvoid*s 是要求的第一个地址，char ch是初始化的值（也可以为数字），n为sizeof( a ) **前N个字节\nint arr[10];memset(arr, 0, sizeof(arr)); \n\nchar str[100];　 memset(str,0,100);\n\n更重要的是，memset在结构体初始化方面的运用\nstruct sample_struct　 &#123;　　     char csName[16];　　     int iSeq;　　     int iType;　 &#125;;struct sample_strcut stTest;memset(&amp;stTest,0,sizeof(struct sample_struct));\n\n如果是数组的话\nmemset(TEST,0,sizeof(struct sample_struct)*10);\n","categories":["计算机"],"tags":["数组初始化","结构体初始化"]},{"title":"从逆序对到归并排序","url":"/2025/10/29/fouth-blog/","content":"原本在思考逆序对的简单方法，发现冒泡排序的求法还是太慢了\n\n\n#include&lt;stdio.h&gt; int a[50005],t[50005];long long ans;void merge(int a[], int head, int tail);void merge(int a[], int head, int tail)&#123;\tif (head == tail)  return;\tint mid = (head + tail) / 2;\tmerge(a, head, mid);\tmerge(a, mid + 1, tail);\tint i, j, k;//i用于临时数组t的索引，j是左半区间的起始索引，k是右半区间的起始索引\tfor (i = head, j = head, k = mid + 1;i &lt;= tail;i++)  //i从1遍历到tail,j是左半区间的起点，k是右半区间的起点\t&#123;\t\tif (j == mid + 1) //如果左半区间全部处理\t\t\tt[i] = a[k++];\t\telse if (k == tail + 1) //如果右半区间全部处理\t\t\tt[i] = a[j++], ans += k - mid - 1;\t\telse if (a[j] &lt;= a[k]) //左空间元素小于右空间元素，放左边的\t\t\tt[i] = a[j++], ans += k - mid - 1;\t\telse t[i] = a[k++];//否则放右边的\t&#125;\tfor (i = head;i &lt;= tail;i++) a[i] = t[i];&#125;int main()&#123;\t//归并排序\tint n,i;\tscanf(&quot;%d&quot;, &amp;n);\tfor (i = 1;i &lt;= n;i++)\t\tscanf(&quot;%d&quot;, &amp;a[i]);\tmerge(a, 1, n);\tprintf(&quot;%lld&quot;, ans);&#125;\n\n\n\n这是具体模拟整个过程\n当然，这个过程已经实现了排序功能，t [ ] 是排序后的数组，元素从小到大排列。如果想从大到小排列，也可以将 ’ &lt;&#x3D; ‘ 改为 ’ &gt;&#x3D; ‘  。\n这题也可以用树状数组、线段树 、Trie树（字典树）\n","categories":["计算机"],"tags":["逆序对","归并排序"]},{"title":"Hello World","url":"/2025/10/26/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post$ hexo new &quot;My New Post&quot;\n\nMore info: Writing\nRun server$ hexo server\n\nMore info: Server\nGenerate static files$ hexo generate\n\nMore info: Generating\nDeploy to remote sites$ hexo deploy\n\nMore info: Deployment\n"},{"title":"一道时间线管理的模拟题","url":"/2025/11/04/the%20fiveth%20blog/","content":"题目来自2024年学院期中，是一道关于时间管理的模拟题题目描述饭堂有个窗口,一个阿姨在卖肠粉。阿姨不会提前制作肠粉,只有在同学点餐后才会开始为该同学制作肠粉。阿姨制作肠粉的流程是,先花费t1时间处理原材料,然后放进肠粉机里蒸煮t2时间,煮好便可以立刻交付给同学。阿姨一次只能处理1份原材料,而阿姨有2台肠粉机,每台肠粉机一次只可以蒸煮一份肠粉。注意,阿姨处理原材料是独立于肠粉机的,也就是说当2台肠粉机各自蒸煮着肠粉时,阿姨也可以同时执行其他份肠粉的原材料处理。一共会来几个同学,其中第i个同学会在t=i^2时刻到达窗口排队并点一份肠粉。问:n个同学的等待时间总和是多少? (每个同学的等待时间是【拿到肠粉时刻】-【到达窗口时刻】)输入格式 仅一行,3个正整数,依次是t1,t2, n输出格式 输出一个正整数 tot,表示所有同学的等待时间总和。输入样例1 3 7 10输出样例1 100输入样例2 10 1 10输出样例2 194数据范围 t1, t2, n∈ [1,105]\n\n这题比较像午餐问题、餐厅排队叫号问题、任务调度问题，做法是将 阿姨处理每份原材料的开始时间、第一台肠粉机的处理每份肠粉开始时间、第二台肠粉机的处理每份肠粉开始时间 看作三个数组，记为a[n] b1[n] b2[n]，这题就转化成求这三个量之间的关系，有点像数学里的数列题，去找这三个量的递推关系即可。具体代码如下：\n#include&lt;stdio.h&gt; #include&lt;stdlib.h&gt;int max(int x,int y)&#123;\treturn x&gt;=y?x:y;&#125;int main()&#123;/*         1 4 9 16 25 36 49 64 81 100             1             4        9            1   1+t1       max(1+t1,4)          存开始做的时间              a[i]= max(a[i-1]+t1 , i*i)                        &#123; max(a[i]+t1,b1[i-1]+t2)               b=min&#123; max(a[i]+t1,b2[i-1]+t2)             */     int t1, t2, n,i;    scanf(&quot;%d %d %d&quot;, &amp;t1, &amp;t2, &amp;n);    int* a = (int*)malloc(sizeof(int) * n);    int* b1 = (int*)malloc(sizeof(int) * n);    int* b2 = (int*)malloc(sizeof(int) * n);    for(i=0;i&lt;n;i++)    &#123;    \ta[i]=0;    \tb1[i]=0;    \tb2[i]=0;\t&#125;    a[0] = 1;    b1[0] = 1 + t1;    int t = t1 + t2;    for (i = 1;i &lt; n;i++)    &#123;        a[i] = max(a[i - 1] + t1, (i+1)*(i+1));        if (max(a[i] + t1, b1[i - 1] + t2) &gt;= max(a[i] + t1, b2[i - 1] + t2))            b2[i] = max(a[i] + t1, b2[i - 1] + t2),b1[i]=b1[i-1];         else            b1[i] = max(a[i] + t1, b1[i - 1] + t2),b2[i]=b2[i-1];        t += max(b1[i], b2[i]) + t2 - (i+1)*(i+1);    &#125;    printf(&quot;%d&quot;, t);    return 0;&#125;\n","categories":["计算机"],"tags":["模拟流程","多资源任务分配","时间线优化管理"]},{"title":"程序设计期中知识汇总","url":"/2025/11/05/the%20sixth%20blog/","content":"根据11月4日视频课分享内容，将前半学期所学知识进行汇总，以供复习第一部分：编程知识输入整型数\n\n\n类型\n范围\n\n\n\nshort %hd\n-215~ 215-1\n\n\nint %d\n-231~231-1\n\n\nlong long %lld\n-263~263-1\n\n\nunsigned int %u\n0~232-1\n\n\nunsigned long long %llu\n0~264-1\n\n\n浮点数\n\n\n类型\n精度\n\n\n\nfloat %f\n6位小数\n\n\ndouble %lf\n15位小数\n\n\nlong double %llf\n18位小数\n\n\n字符char %cstring %s\n输出printf(&quot;%f\\n&quot;,r);     正常输出printf(&quot;%10f\\n&quot;,r);   长度为10，空格填充，右对齐printf(&quot;%10.2f\\n&quot;,r); 长度为10，两位小数，空格填充，右对齐    printf(&quot;%-10.2f\\n&quot;,r);左对齐，同上   printf(&quot;%+10.2f\\n&quot;,r);右对齐，显示正负号     printf(&quot;% 10.2f\\n&quot;,r);右对齐，空字符填充printf(&quot;%010.2f\\n&quot;,r);右对齐，0填充具体效果3.140000  3.140000      3.143.14     +3.14      3.140000003.14\n除此之外还要特别注意的有%o 无符号八进制整数，不输出前缀0%u 无符号十进制整数%x/X 无符号十六进制整数，不输出前缀0x,字母有大小写区分%e/E 科学计数法，e有大小写区分%g/G 有效位数，如%.8g保留8位有效数字（自动简化）%p 以十六进制形式输出指针%n 不读取任何字符，只读取截至目前读取的字符个数\n其他常量 const转义字符\\n \\&quot;存储类 static  extern\n运算符位运算（整型、字符型）&amp; 与| 或~非^异或&lt;&lt;左移&gt;&gt;右移\n三目运算符a &gt; b ? a : b\n类型转换隐式类型转换float a = 3.2;int b = 2;float c = a / b;\n显示&#x2F;强制类型转换int a;(double)a;\n\n第二部分：编程技巧介绍枚举与模拟列举出所有情况，然后判断是否符合题目要求参考Luogu P1102 ( 需要二分和双指针 )\n报错&amp;调试1.简单调试2.模块化编程3.理解编译错误\nAC - Accepted（答案正确）\nWA - Wrong Answer（答案错误）\nTLE - Time Limit Exceeded（超出时间限制）\nRE - Runtime Error（运行时错误）\nCE - Compilation Error（编译错误）\nMLE - Memory Limit Exceeded（超出内存限制）\nOLE - Output Limit Exceeded（输出限制超出）\nPE - Presentation Error（格式错误）\nTCI - Time Complexity Incorrect（时间复杂度错误）\nMCI - Memory Complexity Incorrect（空间复杂度错误）\n\n常见trick0-index 与 1-index表达式优先级如果不确定可以全打上括号\n处理整数型数据相除得到小数而非整数方法1：强制转换 （double)方法2：在表达式前面加上1.0*注意数据范围常见的范围是：int 最大是231-1 ,long long最大是263-1。\n注意初始化记得给每一个变量赋一个初始值。\n退出循环的姿势如果是在函数里，可以return如果是在主函数里，可以return 0 最正常的写法是break 配合flag&#x3D;0&#96;\n递归模板int func()&#123;    if(终止条件)&#123;        return ?;    &#125;    继续遍历；&#125;\n\n正确开数组一般要在数据范围之外多开5。一般建议开成全局数组，开在主函数里有爆栈的风险。在编译选项里，编译时加入以下命令-wl,--stack,268435456.同时，单个数组大小不要超过107,不然会编译错误。\n骗分技巧1.编译分2.打表分头文件常见有：stdio.hstdlib.hmath.hstring.htime.hctype.h\n多文件编译一般有三个文件，分别为main.c  function.h  function.c\nmain.c#include&lt;...&gt;#include&quot;function.h&quot;主程序部分\n\nfunction.h#ifndef FUNCTION_H#define FUNCTION_H函数声明int function( );#endif\n\nfunction.c#include&lt;...&gt;#include&quot;function.h&quot;函数部分","categories":["计算机"],"tags":["知识复习"]},{"title":"关于输入输出不得不说的……","url":"/2025/11/06/the%20seventh%20blog/","content":"整理期中考试的第一题，有关字符串输入输出题目描述：输入一串字符，输出这串字符。hhhhh看到的标准答案版本是1.scanf/getchar+EOF2.fgets（读不了换行的）\n方法一#include&lt;stdio.h&gt;int main()&#123;    char x;    while(scanf(&quot;%c&quot;,&amp;x)!=EOF)   条件也可以写成 ~scanf(&quot;%c&quot;,&amp;x) \\ scanf(&quot;%c&quot;,&amp;x)==1    &#123;        printf(&quot;%c&quot;,x);    &#125;    return 0;&#125;\n\n方法二#include &lt;stdio.h&gt;int main(void)&#123;    char x;    while((x=getchar())!=EOF)    &#123;        printf(&quot;%c&quot;,x);    &#125;    return 0;&#125;\n\n方法三#include &lt;stdio.h&gt;int main(void)&#123;    char a[1026] = &#123;0&#125;;    fgets(a, 1026, stdin);  只能读一行    printf(&quot;%s&quot;, a);    return 0;&#125;","categories":["计算机"],"tags":["输入输出"]}]